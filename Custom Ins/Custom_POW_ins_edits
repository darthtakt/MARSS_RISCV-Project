//riscv_opc.h

#define MATCH_POW 0x0400000b
#define MASK_POW 0xfe00707f
funct7=0x04
funct3=0x00
//riscv_opc.c

{"pow",         0, INSN_CLASS_I, "d,s,t",     MATCH_POW, MASK_POW, match_opcode, 0}, 

//riscv_isa_decoder.c
 
//part1
static void
set_op_fu(RVInstruction *i)
{
    uint32_t funct3;
    uint32_t insn = i->binary;  /*the pointer i gets info of ins from RVIins struct 32 bit binary id stores in insn variable in this function*/ 
    int32_t imm = insn >> 25; /*extracting funct7 and putting in variable imm created for this function*/
    if (imm == 1)             /*checking if funct7=1 for mul operations funct7=1*/
    {
        funct3 = (insn >> 12) & 7;  /*extacts funct3 from id*/
	 // Add a test log message:
        sim_log_event(sim_log,
            "Decode reached: funct7=%d, funct3=%d, PC=0x%lx",
            imm, funct3, i->pc);   //sim_log_event added for checking debug process in terminal and log file
        switch (funct3)
        {
            case 0: /* mul */
            case 1: /* mulh */
            case 2: /* mulhsu */
            case 3: /* mulhu */ 
                i->fu_type = FU_MUL;
                i->type = INS_TYPE_INT_MUL;
                break;
            case 4: /* div */
            case 5: /* divu */
            case 6: /* rem */
            case 7: /* remu */
                i->fu_type = FU_DIV;
                i->type = INS_TYPE_INT_DIV;
                break;
        }
    }
    else
    {
        if (imm == 2)      
     	{ 
	  sim_log_event(sim_log, "decode checked fucnt7 of pow");
          funct3 = (insn >> 12) & 7; 
          if (funct3 == 0)
		 { 
		 	sim_log_event(sim_log, "decode chcked funct3 entered fu pow");
           		 i->fu_type = FU_DIV;           // reuse div unit
           		 i->type = INS_TYPE_INT_DIV;
                        sim_log_event(sim_log, "Done");    // reuse div type, or define a new type
        		   
        	 }
     	 }
     }  
}

//part2
static int
chk_op_exceptions(RVInstruction *i)
{
    int32_t imm = i->binary >> 25;                   // funct7
    uint32_t funct3 = (i->binary >> 12) & 0x7;       // funct3

    // Allow standard M-extension funct7=1
    if (imm == 1)
	{
        return 0;
	}
    // Allow your custom instruction funct7=2 and funct3=0
    if (imm == 2 && funct3 == 0)
	{
         sim_log_event(sim_log, "entered pow exception block");
	 return 0;
	}

    // For others, only allow if only bit 5 is set (0x20)
    if (imm & ~0x20)
	{
	 sim_log_event(sim_log, "DANGER ZONE");
        return -1;
	}

    return 0;
}

//part3
case OP_MASK:
            case OP_MASK_32:
            case 0x0b:
            {
                int32_t funct7 =insn >> 25;
                if (chk_op_exceptions(ins))
                {
                    goto exception;
                }
                
                else if(ins->major_opcode == 0x0b && ins->funct7==2)
                { 
                        sim_log_event(sim_log, "POW opcode checked");
                }

                ins->has_src1 = TRUE;   /*this indicates what source registers it uses what it shld read and write to and from*/
                ins->has_src2 = TRUE;
                ins->has_dest = TRUE;
                /* set the functional units for mul and div */
                set_op_fu(ins);    /*calls the set_op_fu set fucntional unit function to execute after checking the sorce and dest registers*/
                break;
            }

//riscv_isa_execute.c

//part1
static inline target_long simglue(pow, BIT_SIZE)(target_long a, target_long b)
{
    target_long result = 1;
    target_long base = a;

    if (b < 0) {
        /* For negative exponents, return -1 as error indicator (like div by zero case) */
        return -1;
    }

    while (b > 0) {
        if (b & 1) {
            result = result * base;
        }
        base = base * base;
        b >>= 1;
    }

    return result;
}

//part2
else if (imm == 2)
    {    
		sim_log_event(sim_log, "entered POW execute block");

	    funct3 = (insn >> 12) & 7;
	    if (funct3 == 0)
	    {   
 		sim_log_event(sim_log, "funct3 for execution checked");
	      
		
		
		   i->buffer = simglue(pow, BIT_SIZE)(i->rs1_val, i->rs2_val);
		    
		
	    }
    }

//part3
execute_riscv_instruction(RVInstruction *i, uint32_t *fflags)
{
    int32_t rm;

    /* For 16-bit compressed instructions */
    if ((i->binary & 3) != 3)
    {
        execute_ext_c_path(i);
        return;
    }

    /* For 32-bit integer and floating point instructions */
    switch (i->major_opcode)
    {

        //other cases
        case OP_MASK:
        case 0x0b:
        {
            execute_op(i);
            break;
        }

   }
   
//riscv_isa_string_generator.c
static void
set_op_str(RVInstruction *i)
{
    uint32_t funct3;
    uint32_t insn = i->binary;
    int32_t imm = insn >> 25;

    if (imm == 1)
    {
        funct3 = (insn >> 12) & 7;
        switch (funct3)
        {
           //other cases with funct7=1
    }



     else if (imm == 2) // Custom POW instruction
	{
   	 funct3 = (insn >> 12) & 7;
    	 switch (funct3)
    		{
        	   case 0: /* mod */
        	   {
            		snprintf(i->str, RISCV_INS_STR_MAX_LENGTH, "pow %s,%s,%s",
                        reg[i->rd], reg[i->rs1], reg[i->rs2]);
            		break;
        	    }
    		}
	}

    else
    {//other cases when funct7!=1
    }
